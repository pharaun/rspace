use std::str::FromStr;
use asm::types;

grammar;

match {
    r"(CYCLE|TIME|INSTRET)H?" => CSR,
} else {
    r"[0-9]+"                 => NUM,
    r"0x[0-9A-F-a-f]+"        => HEX,
    r"x[0-9]+"                => REG,
    r"[0-9]+[BFbf]"           => NUMLAB,
    r"[A-Za-z.]+"             => STR,
    _
}

// number == digits + Ox{digits} (does not handle negative number) unsigned int32/64) (later can
//                              handle negative by converting it to 2's compat and  storing it as unsigned)
pub Number = { Dec, Hex };

Dec: u32 = <s:NUM> => u32::from_str(s).unwrap();
Hex: u32 = <s:HEX> => u32::from_str_radix(&s[2..], 16).unwrap();

// Register == letter + digits
// For now only support x{0-31} styled registers
pub Register = { Reg };

Reg: &'input str = <s:REG> => s;

// CSR & priv inst
// csr == ?
// For now, support a discrete list of csr + priv insts
pub Csr = { CsrReg };

CsrReg: &'input str = <s:CSR> => s;

// Labels (local label, word label)
pub Label: types::Labels <'input> = {
    <n:LLabel> => types::Labels::NLabel(n),
    <n:WLabel> => types::Labels::WLabel(n),
};

LLabel: &'input str = <s:NUMLAB> => s;
WLabel: &'input str = <s:STR> => s;

// args = register | number | csr | label
pub Arguments: types::Args <'input> = {
    <n:Register> => types::Args::Reg(n),
    <n:Csr>      => types::Args::Csr(n),
    <n:Number>   => types::Args::Num(n),
    <n:Label>    => types::Args::Lab(n),
};

// [0-4] args
pub VecArgs: Vec<types::Args <'input>> = {
    <Arguments*>
};

// Instruction == letter + .
Instruction: &'input str = <s:STR> => s;

// Asm Line = Instruction [0-4] args
// TODO:
//  gcc as assemblier uses a slightly different syntax:
//      - add x0, x1, x3
//      - lw x0, 0x0(x3)
//      - sw x0, 0x0(x3)
//      - csr{rw, rs, rc} a0, cycle, x0
//      - csr{rw, rs, rc}i a1, sscratch, 1
pub AsmLine: types::AsmLine <'input> = {
    <l:NUM> ":" <i:Instruction> <v:VecArgs>    => types::AsmLine::Lns(types::Labels::NLabel(l), i, v),
    <l:WLabel> ":" <i:Instruction> <v:VecArgs> => types::AsmLine::Lns(types::Labels::WLabel(l), i, v),
    <i:Instruction> <v:VecArgs>                => types::AsmLine::Ins(i, v),
    <l:NUM> ":"                                => types::AsmLine::Lab(types::Labels::NLabel(l)),
    <l:WLabel> ":"                             => types::AsmLine::Lab(types::Labels::WLabel(l)),
};
